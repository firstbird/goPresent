GO ≈‡—µ-- go -talk

experimental -- web dont believe this tis the answer to everying ,but we re playing

concurrent -- important in modern world

Systems language -- write things like web servers and other ,
you have more control ober some things and you have another languages like say ,JAVA
and python,
but it works like a systems languate when you use it .
it is very good at things we find for things like front-ends or just general programming
so although it is designed as a systems language it has much broader use than just that 
I cant give a talk without showing you' Hello world '

it looks vaguely C like although there is some werdnesses about it , I wont talk about what
werdnesses are who is involve webll im giving talk but it is by no means my project There is a bunch 
of people involve and Iwant to make sure everyone is cleared, some of the names are reallly 
important here 

we want a program fast we want a program fu and to make programing fun you have 
to fine ways to speed things up and make things work better not just the code itself but 
the process of writing the code needds to be efficent . So whats happened
web know program used to be fun . what went wrong? webll it is interesting there been really
no new major systems language in at least 10 years or could be longer,but in that decade 
a lot has changed , the libraries have gotten bigger . professional programming has, to a larger
extent, become a layering process and so we layer more and more stuff on and we alse broaden out
the base .The libraries got really big. There is a lots of them. they communicate with dependencies to one 
another and so the fore has become a thicket and at some times it is kind of hard to cut your way through 
it .networking has pretty much taken over the world that the way to think about computing,The old son thing


to is too slow to build software, the tools are slow, they have a hard problem todo but they stil--
they re tend to be slow and they re getting slower,Thecomputers have speed up enormously but the software
developent process ,if anyting has gotten slower over the last ten years 

the dependencies are uncontrolled and the languages dont help you control them .so you spend a lot of time 
maybe building things you dont even need but you dont konw it cnat prove it the machines have also stopped getting 
faster, they ve gotten more but they havent gotten faster there are more processors ,there are more of them
but the actual clock speed has ardly changed in the fast few years  and Moores law, to some extent is peering out 
and yet the softwre gets bigger and bigger and bigger, and somehow it feel ike if web dont do something then software
contruction is just going to become unbeatable slower and we need to think about the process of making it fast again
Robert observes that a lot of eht interesting work in languares in the last few years is been because a lot of the people 
using these standards systems languages like C C++ ,JAVA are finding the clamp the type systems are very sort of 
clumsy or hard to work with . and as thye go to eht dynamic languages: the pythons the rubys,enen the javascript
of the world ,they have a lot more fun because the type systems dont get in the way so much at least as long as the
program keeps runnig, and so the challenge is to try to deal with this ,you want typing ,you want a good typing because 
it makes programs robust but it can be donw badly and we are given in some ways there is-- if no done badly ,it should 
at least be done the differnet way ,Sometimes good ideas in principle make bad practice  and a good example of that is 
the const keyword in C and C++ ,which was very well intentioned and seem to address the real need in making program 
safer but it tends to make proramging awkward in a lot of ways ,so this isnt worth the benefit you gt back from using 
also there is this notion of everything being a type hierarchy in objet-oriented programming and yet he types in large program
dont really natually fall into hierarchies .


----9.27------

we find the way to make them fit but it is a bit of a struggle ,In program web 
spend so much time re=factoring a code ,juggling,type trees aroud , and that has very little to do with the implementtation and lot 
to do with he way the language is forcing you to think .web d like to be --we,d like to sort
 of step back from that model . and in short , therefore ,with the way type systems work today you can be productive 
or you can safe but you cant reallly be both ,and that seems like a shame ; we should be able to fix that so ,why a new 
language , why dont  web just , the languages are thinking ,the way the type systems work the way they re compiled
the way dependencies are managed .the languages themselves have these problems endemic in them and to fix them 
you have to rethink the languares itselft, for instance the libraries cant help you because adding anything  to try to fix 
some of these probelm is going in the wrong direction. there is too much already . web need to trim down ,cut the fat
and make things cleaner ,fixing it by adding software isnt going to do it. you have to sort of step aside and do
something separate and so we decided ,just take a step away and think about the way programs 

what is the goal of the language, 

of the story is we want the efficiency of a statically compiled language ; that means truly compiled language, but the
ease of programming of a dynamic language . and i think we have come pretty close to achieving that . 
you can decide for yourself as we go on . safety is critical. It is critical to the language , the type-safe and then
the memory-safe, it is important that a program not be able to derive a bad address and just use it ,that a program
that compiles is type -safe and memory-safe. that is critical part of making robust softsare and we just --that is 
just fundamental web want good support for concurrency . 
I ll talk a little bit about that . Communication ,I ll talk about that too ,Those are tools,that can help you build software that
runs in the network or in multi-core CPUS .we want to buld -- we re going to garbage like to think because a lot of the
bookkeeping that goes on inside modern programming ,especially in C,C++ ,has to do with memory management 
and that can be totally automated . and we believe is the word ,that you can do that efficiently and essentially ,latency
-free that the garbage collection tchonlogy is advance to the point where a garbage collected systems language actually
makes a lot of sense.
and os we d like to do that ,and also ,we d like the compiler to just run fast,eveyone knows this slide and there s some 
truth to it .you know you spent too much time waiting
for compilers so let me give you a compilation demo here. this is a directory of go code if you look

to do this language we had to have some principles on which is built 
and there are actually some fundamental principles in here that in some ways ,I think differ from some of the other
languages out there . so i d like to go through them . one of them is that we try as much as possible to keep the concepts
orthogonal, for instance, in the interface surface , i ll talk about the concept of implementation versus interface or completely 
orthogonal ,they re two separate things they dont interact and you dont define them together , you define them in 
separat objects and that makes a lot of stuff cleaner. and in practice this is because a few orthogonal features that 
cover the space work a lot better , in practice than a lot of overlapping lines. thats a principle thats a little vague
but i think , you know what im getting at . the grammar is very regualr  and very simple,
It is actually confict free and can be parsed without a symbol table , there  is no conflicts in it ,that makes it easier
to write tools ,likes IDES or editor plug-ins ,and things like that debuggers because the parsing line is understanding
and the program is actually pretty straight forward , we try to reduce the typing ,what i mean by that is that we want 
the language to work things out . you tend to type too much when you re programming in modern object or in languages
you tend to write statements like that ,thats literal ,if you chage foo for a much longer word ,thats an example i found 
in some code i want to end ,and i just you know ,foo should just go away , you should nt have to type all those foos 
that is crazy.
so you want to get rid of the  bookkeeping ,you want the type system to automatically works the Foo, but you still want 
to be safe,you  ant it--you want it tobe type-safe ,but well handled .and also, not only you dont want to reduce typing 
you want to reduce typing ,you want to type so sort melt away into the background.you want it to be clear, you dont want 
to type hierarchy we dont  want to type hierarchy, and then i ll show you some examples on why that actually helps ,we 
just think,
the program by constructing type hierarchies, is not the way to go ,we have an alternate world .
However ,go is a profoundly object-oriented language ,arguably, more object-oriented language--more object-oriented
than say java or c++ and i ll show you why ,so the big picture,
there is some fundamentals, web have a clean concise  syntax. we have very lightweight type system. we got rid of implicit 
conversions, because they re all inconvenient. they tend to cause a lot of confusion particularly in the old C rules for 
things like the ,you know, the usual conversions are actually not all that usual and now these got right so everything
is very clear and very clean on what is going on in the page ,of course ,when you know the vonversions. you tend to 
do a lot of casting or conversion by hand and that is messy ,so we address that by changing constants pretty prfoundylly
i ll talk about that in a little bit . you ll never you wont see 0x80ULL in go program . the ULL is completely pointless,
you cant even say it ,numbers are just numbers and there is a strict separation berween the interface and
implementation thats part of keeping the concept orthogonal and the type system clean. so there is a runtime , there is
garbage collection,there is a good support for strings ,maps, associate raise ,that kind of thing ,and also the communication
channels which we ll talk about ,and then there really strong support for concurrency .
it is actually some of the best concurrency stuff ,i think,thats out there , its really good ,and then there is a package model, 
which i wont talk very much about because its kind of takes  a lot of explaining . but the notion here is that inside the 
packages,everyting is explicit . what you depend on is explicit , Compiler rejects your program ,if you put in the dependency 
you dont need ,it is all very clean and so , it makes tools easy to understand dependencies and then it makes the builds
guaranteed minimal . so ,that helps enormously . regarding the dependencies the linking going faster ,the compilation
can go faster but-and there is actually a notion in here that i think is important,
the compiler actually pulls the transitive dependency information up the tree as it is compiling ,simply to reduce the 
number of files it has to look at ,which in turn speeds up the compilation proess , so if you have a program, a.go, 
that depends on b.go, that depends on c.go, which is pretty standard kind of thing ,you--in the usual way,you have to 
compile them in reerse order ,because ,you got to build the dependent stuff before the depending stuff ,but the point 
is when you go to compile ,a.go, it doesnt need to compile C ,it doesnt need to look at c.go at all. it doesnt even need to 
look at the object code code for C ,because everything that B need from C has already been pulled up into B.go, and that
doesnt sound like a big deal ,but when you  re at scale ,it is  literally exponenttially faster at building software when you
get in to this huge dependents situation . for concurrency we sort of have a model , i ll touch on it today, there is a lot 
more stuff online about it ,but we have a sugggest for how to wirte system and servers as concurrents garbage-collected 
processes ,which we called ,goroutines . we ll have good support form the language and the run-time we change the name because 
they re slightly different from what you re used to . if you use the words like thread or process or goroutine,
thats not quite the same ,so web have our onw word ,goroutine ,the language takes care of managing the goroutines and managing the 
memory that they use and the communication between them ,Stacks grow automatically ,thats taken care of by the language ,you
dont have to declare how big the stack is going to be ,if needs a bigger stack ,it gets the bigger stack ,if it needs a smaller stack it
uses lessmemory , and those stacks are multiple -- i m sorry ,the gorotines are then multiplexed on the threads ,that is all done 
automatically  for you and [INDISTINCT] tansparently . and one of the feature -- one of the reasons for needing garbage
collection is that concurrent programming is very hard without garbage collection, because as you hand itms aroud between this
concurrent things ,who owns the memory ? whose job is it to free it ? and there is a lot of bookkeeping involved that the --if the 
language or the system doesnt take care of that for you ,so you need garbage collection to make concurrency work well ,on the other 
hand you need -- to get the garbage collection to work well ,you need a language that makes garbage collection a feasible thing to 
do ,which is anothoer argument for doing a new language , so i dont have time to explain all of go to you 
it is bigger than c not as big as c++,
im going to go through about a dozen slides that are -- i hope sort fo representative of the kinds of things that go on ,but ,i m 
going to leave out quite a bit 

basics 
it looks a little bit like c actually a little more than like c than this slide ,we let you beleve ,there is usually a keywords involved ,
introducing things ,you see const and var,const
Cosnt,taht means it is a constant, not --it is not the const keyword form C , it is completely different meaning ,it just means 
,int the first line there ,N is constant 1024,and it is just a number ,it is not an int ,int is not a float, it is not an unsigned int,
it just a number, and there is a const string,and you can see we support unicode just fine , infact the language requires that
the input be UTF-8 encoded ,and then ,you can declare variables with the "var"
 keyword in the usual way ,you ll notice -- im quite use to it now ,but for c programmers this looks backwards,
because in c ,you put the flout before the X and Y ,but they re reversed ere is a long explanation on the web about why we 
did this ,but the fundamental reason is it actually has been cleaner because ,for instance, 
int that declaration ,X and Y both have type float. Whereas ,if flip it around put the keyword first ,things get a little funnier,
and you can see what the C version of that will look like ,you d have to reproduce the star, so this is simplification you get,
there is  characters ,unicode supports ,and stuff like taht ,then we in this example  ,was not really an eample ,just some 
lines of code ,there is a type struct ,T ,that is defined ,it is got a couple of fields within if they  re both integers ,then we declare 
a ariable ,t0,which  is a new T,that should be pretty familiar what that means . Butthere is too much typing going on there ,
so the next line there ,T1 :=new(T), thats  an old notation from some languages that i work with before , whtat taht call and equeals 
means  is declaring the initialized . so that --those two lines are equivalent ,var t0 *T= new(T), it has too many Ts in it .
we can get rid one of them by jsut having the type of t1 we derive from the expression,thats used to declare and initialize it ,
and you ll see that used a lot in go code. the var doesnt show up nearly as much as the colon equeals notation ,their control 
structure is they re actually quite interesting control structures --just the first blast through.
pretty the same as C , they re actually quite richer ,ut the basices are the same ,the main difference is syntactic .the braces are
required on the blocks and there is no parenthesis on for isntance .the conditional expression inside an "if " statement ,thats 
just to clean up the gammar, so here is a real program. it's not hello world ,it s echo this time ,but it's got all the parts,the first
time the code says "package main ",that has some meaning int the language about me get muted. we re thinking about simplifying 
a few things but at least for the monent it is "package main" .then you can see there's a  fucntion called "main" is declared down 
below  and the program begins execution by starting "main.main" intializaiton inside. there is a declaration of the flag from 
the flag's package ,so that makes minus N ,turn off new lines form echo, it is not strictly a UNIX echo because  it is got real 
flag parsing ,ut it's essentially the same,those import statements say , "we re going to use package OS",which does some stuff 
for us and we re going to use the flag package ,obviously ,now the way the initialization stuff works  ist that in-flag variable
will be initialized before "main" starts executing . all the golbal variables get initialized by --and they an be initialized by
arbitrary complexx stuff before "main " starts ,so then in "main", we do the flagparts that get the command line pulled apart ,and 
then we just loop voer the argumnts which are now the [INDISTINCT] the flag package , and it's  the obvious loop accumulating,
you can see += on the string there to append to the string ,and stuff like that ,and then at the bottom ,the flags are actually pointers 
in GO ,the package makes them pointers ,so the *nFlag, which is a Boolean , is false ,Then you add a new line to the end of it ,and then 
finally ,you do a method called "os.stdout " to get the open-up ,so ,although retty much every line in here is different fromwhat you 
ve seen before ,it should be perfect and clear what is going on , i dont think you ll find that a mysterious proey re jsut numbersgram. so let's talk about
constants ,i siad they are l little dirrerent constants  in go are what we like to think of as sort of type-less. they have no type .
they have no size. they are just numbers or strings ,you can have constants and stirngs in Booleans, but numbers are the interesting
case, so in this little snippet here is just some constants being used ,we start by defining a type TZ for time Zone ,which is an integer
and then, wedeclare some constants ,UTC and EST ,We declare them to have type TZ and assigned to those initial vlues ,you can clear whats 
going on there ,the parenthesis aroud the const is distributingthe const declaration introducting keyword across the elements inside 
that declaration ,so that is the same as saying ,"two const declarations with the two variables int them ",you ll see later on th
e next page here that actually matters that you can group them like this ,because there is a thing called iota, which is an enumeratin
constant ,It literally -- for each const declaration counts which element you re on ,at every semicolon ,it increments ,starts at zero on
the next line ,it is one ,the next line is two ,and so ,here you can see ,we re declaring bit0 and mask0 to be uint32s ,and the first one is 
set to one shifted up iota, lota starts at zero in every ocnst . so that is one shifted up zero and one shift zero minus one . so thats 
a bit and a mask . and then the next line does it again ,but now iota has gone up to one. so we get the next guy in the sequence 
,you can see how to use that to build enumerated constants but this is a slightly richer example and again , to reduce typing ,if you want
you can just say ,declaration, like the third line there with the semicolon and what that says is , "just keep doing what i did " take the 
declaration initializer form the previous line then pretend that you just type that here , and so if you wnat to declare a new ready constant ,
you can say ,const open parenthesis inum0 equels iota semicolon and then you just go inum1 semicolon, inum2 semicolon and all the way the page 
.and all the way down the page , and just have them declare sequential njumbers for theri constants one very important properties of these numeric
constants in go ,is it there are arbitrary precision . so ,here  is a const ,the logarithm of 2, you can see that is got like 40 or 50 decimal places in it ,
which is more than even a float 64 can represent . But that's a valid declaration ,because they re just numbers, and then the next line ,we can actually 
compute log2 ,log base 2 of E as one over log of 2 ,and that;s a precise division because it's happening  not in floating point space but in arbitray number 
presision space .So that's a very accurate reciprocal .And that kind of stuff is nice too ,because  you dont see cache and conversions and ake tworries about 
overflows and underflows. Constants just take the job for you ,and then we have values ,obviously ,there 's an array like type called the slice, those are arrays 
like type called the slice .those are arrays but they're kind od preculiar . you dont use them much. Instead use a reference type called the slice .So we can there , is declared to be a slice of strings with Saturday and Sunday as strings declared inside it .And then we take the timeZones and make declare timeZones map to be a map form a string to TZ or timeZone. and you can see how that works .it's prettystraightforward. There's a fucntion declaration to do 
an "add" .you can see the function syntax there . there's actually a lot of interesting things in how functions deal with return values ,which im not going to 
talk about today ,but you should check that out ,and  then there's a declaration of function type which takes two integers return int ,so "add" is of type Op.
And then ,here we declare an RPC ,which is a structure. i showed that before but it's a example ,it's got A and B integers ,it's got operator ,and it's got a result 
which  is a pointer to an integer . And all that should be farily straightforward evne if the declarations look backwards to a Cprogrammer, and then the last
line there, we declare using a structure literal ,an instance of an PRC and again ,it's very simple ,you just say type name ,open brace ,list the elements of the 
structure , closing brace and then you got a value , you can assign that to or in this case ,initialize a new variable to that value .
So I said[INDISTINCT] language ,We havent seen much yet ,there was actually one and the other is a method in the echo exmaple where we wrote the os.Stdout. But let's talk about methods ,because they 're kind of different. So here 's a type called point that has X and Y .Now ,those are upper case and 
the reson is ,in Go ,the complete decison about whether an indentifier is visible outside the package or not ,is whether or not it starts with an uppercase 
Unicode letter, That's it . Soif a variable or a type or whatever declared at the top level is uppercase is visible to ehe clients of the package. If it's lower case
,it's not ,Inside the golbal struct ,if a method or field is uppercase, it's visible to the clients of the package , otherwise ,it's not . that's it .It's really simple .
So,there's that type .Now, we're going to define a couple of methods on it , the declaration syntax for a method , you ll notice it's not declared inside the 
struct, and the reason ,we'll see in a minute, is a method and structs are independent ideas, you can have methods on things other than structs ,so it wouldn't make sense,if you put them inside the struct declaration . what you do si you say, "Here's a func ." 
and then before the name of the method ,you write a parenthesis,, kind of like its own little one element parameter list ,receive a declaration and 
receiver is a short hand for that thing that's receiving the method when it's called . So this says ,that scale is a method of type star point and it takes a 
float argument and then the implementation is inside and it's just multiplies up the point by the usual ,by the scale factor, you'll  notice that the receiver is explicit. there's nothis ,automatic or anything like that. you have to actually say ,declare receiver  and use it if you need to access the fields of the struct
insdie the method .And then there's Abs , you can imagine what that is. There's a square root ,which is a cuntion inside the math package computing the hypotenuse ofthe point of the [INDISTINCT] of the vector. and then here's --we declare an X.Now,this time you notice there's an ampersand before the point, word there . Point of three ,four is a value ,Ampersand of point of three ,four allocates. It's like a constructor like thing to create a pointer to a new 
instance of that. And that --every time you execute taht ,you get a new instance of point that initializes the three ,for ,Then you can call x.Scale ,which is assumed you'd expect ot be able to do.Okey .Sothat's pretty simple . the syntax is slightly different but the ideas are pretty simple .Now ,it gets more interesting because methods on any type you define .And here's a full example ,this is another complete program that actually does something a little different. So again, we start with package main and now we importfmt,which ist the formative printing package. It has printf and stuff liek taht in it .And 
then here's ourtype TZ int coming back. and now we declare few more of these constants ,we have an Hour which is of type TZ,which 
is 60 minutes times 60 seconds .And then we declared ,just to make it short ,two timeZones: Zero hours and minus five hours for UTZ and EST ,okay?
Nodw ,we declare a map from the names to the values of those timeZones. That should be familiar in the timeZones .We actually have that exact the same example before. And now ,we put a method on a timeZone .Now ,timeZone is just an int ,but I'm going to put a method on it ,So, I declare a fucntion called capital string that returns a string to receive ts , lower case ,plus a type TZ, upper case ,Notice that it's not a pointer ,that's really important. It doesn't have
to be a pointer. and then ,using a varint of the for-loop that's arranged over the elements of a collection, I say name comma zone is range of timeZones ,What I'm looking for is the element of the timeZone map whose value is equal to the value of TZ. That's the name of the guy I want. So it's like reversing the map . So I just loop over all the elements looking for the one whose timeZone is equal to the zone of that element of the map and if that's true I return the name .And you can see there's actually quite a bit going on in there . There's the range which is giving you the iterator ,there's a cone [PH ] equals to declare loop variables that work over the elements and thing inside in and all not . But of course you might get a value of the-- of TZ integer that's not an exact timeZone number .And so ,if that happens ,we finish the loop and we return fmt.Sprintf of blah-blah.An Sprintf is analogous to the standard C as printf, but actually returns a new string . It doesn't put into a buffer. So ,that's an implementation of a method that let's you print timeZones in interesting ways .So we can use it in our main function by saying ,if we just say,fmt.Println of EST ,Println is a variant of print that doesn't  require a format. It'll work. It'll actually printout EST by caching it in the inner loop of the string method. and notice that Println(EST) knows under the covers by mechanisms that are described the length and the website,how that the timeZone type has a string method and that's how you should pretty print it if you get a value of that type. So , that's all  you need to do make it print itself. And then ,there's another example, we can print Println five tiems hour over two and it comes out as plus two colon thirty, because the printf at the bottom works , Sothis is a fairly contrive example ,but you can see to there's a [INDISTINCT] going on here ,Having methods on general types as any small talk programmer will know , a very convenient thing to do ,But by separating them methods away from structural classes, we actually introduce some new ideas that you can play with and that's pretty fun .Okay ,So new ,we come to something that Iwill not be able to describle in full in the time available ,but they are pretty interesting and they are arguably the most noble about go and that is the concept of an Interface, an interface is an what's the word ,a formalization of the concept of a set of methods ,So ,we can declare a mtthod ,sorry ,an interface type magnitude and say that anything that implements the Magnitude interface is something that implements the Abs method that returns a float. and of course there could be lots of other things in there ,but we'll assume for the moment there's just one .So ,remember we declared an Abs method for the type star point .So we can -- we had an x from the previous slide ,we go back there ,that x address the point three,four ,that's the same x. we can use it here .We declare a variable with the interface type magnitude and assign it to assign to it the value x. And the reason we can do that is x is an implementation of that interface , and so that's a valid assignment, okay? And having done that ,had I typed var m magnitude instead of m magnitude .No, Igot it right .Sorry Iconfused myself. var m magnitude is a variable ,we assign to x and then we declare a newe variable mag that's m.Abs , so it's just the ,the vector length of the point x. But now we declare another type point three which has three coordinates to find the Abs method for that ,same idea. And now ,we can assign m equal to a point threee and that valued still is an interface var , but inside it is an object that has the implementation of the Abs method . And so we can call the Abs method on that and add that to the variable that we've got .And then we can do it again ,and this time just to be fun , we declare a polar object ,which is Rand theta and , of course ,that's a capital theta because a public field. And then ,we declare p Polar. Notice there is not a pointer this time .Why make it a pointer,it doesn't matter .So we just make it a value polar and it returns the radius of the thing which is the definition of the magnitude .And then we design a value that type to m ,and now we can add another thing at the magnitude. Sothe interface variable is letting you define, "I can work with anything that implements these methods and anything at all will do." here ,i use threee different representations of a coordinate ,but they're quite different in character . Under the covers ,it's all very simple. And the key point is that nowhere does point three or polar have to tell you that it implements the magnitude interface. It implemented the fact ,though ,because it satisfies the methods that are defined by the interface .And there's way more going on there than I have time to talk about ,but Ihave to talk about one and very important concept behind them ,which is the generality that they give you ,because any method ,it could be part of an interface ,an interface can be any method ,It's all sort of ,it's not one toone ,it's many to many ,It's all mixed up ,And so a struct of a given type may implement multiple interfaces depending on what interface you are using .And that gives you the opportunity to define very simple interfaces that define very general properties. And a really good example of this is in the IO package and it is called the Writer interface And a Writer is anything that implements a standard write call and that's what we define a standard write call tobe .The ,you know ,there's a slice of bytes that can -- that is the data you're going to write .It has a length inclusively inside it ,so we dont need a byte count .And it returns ,there's that fucntion that [INDISTINCT] before returns a pair ,a count and an error ,but dont worry about that ,Just think about the writer, The writer said anything that implements this standard form of the write call can be used to write it to .It makes sense. This is just --it's almost a tautology .But now ,anything you implement write for can be used by anybody that only needs something that implements write. It doesn't matter where the properties it has .So for intance ,fmt.Printf which is jsut what it sounds ,fmt.Fprintf,pardon me ,which is product much what it sounds like doesn't take a file as the first argument. It takes an io.Writer as its first argument. And a result , you can call fmt.Fprintf on a network connection , apipe ,afile descriptor a buffer , all kinds of other things ,anything that implements write ,a cryptography pipeline , And then ,the way buffer io is done in Go is that there is no such thing as buffer io, there's just buffering .And what happens is if you want to create a buffered version of something ,you give it a writer which is anything that implements write into the covers and it gives you back a buffered version of that same thing that you can use where you canuse where you sued it before .So here's an example that puts that together ,again , acomplete program,Starting with package main ,we import bufio, fmt and os again ,And now ,we wrote the os.Stdout before ,but now were going to use Fprintf to write to it to make it explicit. So we say,fmt.Fprintf os.Stdout hello. Then ,we call buffio,NewWriter.We pass it os.Stdout but NewWriter only --all it cares about os.Stdout is that it implements the right call. And the NewWriter function inside bufio returns something else that implements the writer interface , and so I can write ot it .So ,I can call fmt.Fprintf of buf and now I have a buffered write .So Ibetter flush it when  I'm done .But you see the Fprintf use two different types in there for its output and it worked , because underneath -- if you look at the Fprintf declaration ,all it cares about is that the thing that is being passed in implements the write call, which of course they do and it's type checks ,so you know they do ,So, there's a lot more of that stuff  to talk about to ,but we're trying to skip through the highlights . Communication channels are little as radical than interfaces because they're based on ,worked on in some early language ,going back to a Hoare's CSP ,But unlike Hoare's original CSP ,the communication is donw through first-class values called Channels.His second round of it donw about 10years later had these .but we'd played with them linguistically by then .And ,the ideas,you make a Channel , it has type string .That means you can send and receive strings on that channel .Just like a pipe that you can send type values through .And so ,that notation with the left facing out it the communication operator when you used infix it means send .So that sends the string ,hello ,down the channel ,And somewhere else ,some other time, some other Goroutine can do read from channel c by doing a prefix operator on c of that communications and get out the greetings, so it will see greeting as assigned to hello. 
and this haven't done giving goroutine because the channel is synchronized by default hello. you can control thatwehrn you allocate them. and one of the cool things about having them is you can make them--
channels can actually be first class size. that means you can pass a channle on a channel . and i ll show you in a miinute to actually give you some interesting capability .so if you have someone else wants to have 
this channel that you can send greetings on ,you can pass it to him over channel then he can send you greetings ,all right? So, to do that ,though,we have to talk a little bit about goroutines, so ,I ve mentioned some calculations ,it just takes far too long,right? who wants to wait around for that? you're going to block foreever waiting for the calculation, but maybe you dont want to. what you can do instead is create a channel to get anser back on ,and then declare afucniton ,wrapper ,that takes the value of the parameter for the calculation, and a channle invokes the calculation and then when it is donw ,sends the result back .and i broke it in two lines just to make it easier to read . you'd probably jsut write C gets long calcalation of A in a real code ,okay? and then to ru nthe thing .there's a go keword. go is a keyword . go wrapper of 17c  says,"take the fucntion call" , 17 comma C, and run int the backgroud and let me keep going , and then eventually you want to hear what happened , so once you're finished doing your business ,you come back and say,"Okay ,Im rady for the anser now " and you say "Now ,Iwant to receive from C and get the result". So I've taken this calculation and I've solved it off over here and thenit slows back to me by doing a receive on the channle down underneath. that shlould be faily easy to follow. thsi might not be so easy ,but we'll try ,this is a multiplexed server .At least the server side of it ,I'll show you the client ont the next slide. and the idea here ,remember I said you can pass a channle to a channle . what we have is a requst which is a request forthe server to implement .That's trivial ,It just takes a pair of integers in the channel in which it replies ,Very much like what we did before on revious slides ,generalized some what. we defined a binary operator type and we defined a funciton run that takes a binary operator and a request and sends on the reply channel inside the request the value of running the operator on the arguments inside the request.So that's jsut turning to send the operations in the sending of the thing from the previous slide into a funtion ,not very exciting yet .But then ,we defined a server fucniton that takes an perator that is going to serve in a channel of request. And it's just sits in a loop rading request from the service channel and then saying run of Op request, but it puts a Gokeyword at the beginning .So it runs all these requests in parallel in the backgroud . The server is never blocked .It's always ready to receive another call no matter how much is going on ,Obviously there's issues about re=limiting and stuff like that ,but let's not worry about those the key point is that that's ,basically, a server loop ,and then to make it easy to use for the client we defined a public function or an exported funciton by starting with a capital letter ,starts server ,and it says, "Take an operator and start a server for that operator and return the channle on which those requests canbe sent. So. what we do is we allocate the channel ,a channel start a request," we start the server process which in turn is going to start the little implementers of the operator as they come in . and then , we return the channle as the return value from start server .So ,youcall a function you get a channle back, now you got a thing you can talk and that is the fundamental idea on how you use this stuff to build services,So on the client side ,it looks like this ,you say ,server, start server ,here's a function .Now notice that I'm just writing a funcion in line there. Go has four closure,it seems writing down its expressions ,and so now I've got aserver running that's going to add numbers for me .And I've got a channel for that server in the variable server called Lowercase server .I allocated a couple of request in the obvious way and inside the request ,I allocate new channels because I want to do respond to me on separate channles for whaterver reason ,and then Ican send the request to the server ,it doesn't matter what order I send them .It's totally not blocking .I'll just send them anywhere I want. and now  Ican print them out again , print the results as they come back .And I dont have to worry about the order because again ,it's totally parallel ,so in fact , Isend one first but ask her two first ,and iftwo takes forever ,I'll still hang around there waiting forthe response to come back and once it finally does then I'll print the value on one even if one is ready sooner, So thsi one is very rushed through hear, so Iapologize if Ileft you a little be fuddled, but there's examples like this in the tutotial and some other documents,It should make a little clear what's going on if that looses you. Now ,If we go bakc to the server here ,remember I said ,it has a rate limiting issue and also the problem is it runs forever  you want to go and shut it down ,One way to do that is to use a control structure in Go called the Select ,which is quite a rich control structure . But the basic idea is given a set of communications on channels Select let's you choose ,let's you to actually wait for any one of them ot be become ready and once it does become ready ,let that single thing communicate .So it's like a switch statement for communication, So if we repalce the inner loop of server ,which was just ,remember ,get a request and then run Go on it ,With an operator that has a select statement inside it and the second channel called Quit ,that's passed into the server when we create it. Then we can jsut run this normally ,It will just do what it was doing before, but as soon as you want it to goaway , we just send a signal by sending a Boolean of any value ,It doesn't matter what ,on the Quit channel and that branch of the select will fire and this funtion will return ,which is equivalent to exiting the Go routine, So ,that's again pretty quick and I apologize for that ,But Iwant to make sure we hit some of those points. and in fact there's a lot more to talk about ,I havent talk much about package construction .Initialization is actually quite interesting in Go ,It's much -- it's sort of hard ot see ,but it dows a lot for you ,It canhelp you setup things like RPC servers with almost no code and stuff like that .There's fall reflection ,you can reflect from,there,you can reflect on functions ,channels ,maps all kinds of stuff ,It's got interesting some dynamic typing going on if you wanted to ,but you dont have to use it ,There's a thing called Embedding that is a little bit like an inheritance , but some what more simple and yet general There's interators that come out of the way .The reange thing works on fours in our channel's fucntions things like that . And there's some interesting testing software , but Idont have time to talk about any of these right here ,but Ijsut want to make it clear there's a lot more of the language than what I have time to show you ,So let me close his section with another interesting example .This is real communications example .Rememer, we stared this language because we want to build servers . and one of the problems with building servers in the modren world  is there's this model of a thread per request ,which is quite labor intensive and resource intensive to run and quite diffcult to get right in more languages . and we want to make it easy to think about having tens of thouands or even hundreds of thousands of thereads -- whatever they are -- working on your behalf . and to preve that we got some way towards that .This is an wxample that will create a hundred thousand goroutines and then they can do some thing .and what it dows ,you probably wont be able to decode this in real time ,but what it does is it has little function F there that all it does is read a value from a channel,add one to it and send it out again .So there left gets one plus ,get from right ,It's that thing inside F, It jsut passes its token along but adds one to it ,and inside main ,we declare the left most piece -- to go your direction --and then a couple of variables and then for the number of goroutines youwant to start, we sort of thread a new piece on and walk away along ,but we remember where we started, So we stitch together a bunch of goroutines like this ,each of which is passing a channel value along to the next one ,and os ,we end up constructing ,in this case ,a hundred thousand goroutines off turning together like pearls on a string ,and each end is waiting for the guy upstream to give him a value ,So then right at he bottom these after the loop--once we built this thing -- we say drop a value into the right hand side and it goes pfft and pops out the left .and the value that comes out is of course the numbers of goroutines in the because we've added one for each step ,so you can examine that later if it confuses you ,but let me show it to you astually running ,so --I think it was the wrong file, now  i'll run it 

-----
goc goroutine

Compilers 
 let's talk bit about the status ,It's catually quite  a bit to say , we have tow complete implementations in two different compiler technologies .Ken wrote a suite loosely based on some of the Plan 9 tools from scratch 

Run-time 
a Run-time that handles all the memory allocation, garbage collection , stuff like that ,the stack handling stuff which is pretty special but very important. The goroutines support channels, slices map ,reflection ; all of that stuff is built into a real run-time .So even though it's a system language it has a really poweful run-time system including dynamic type reflection. and it's pretty sold . It's improving , it got ways to go especially in memory allocation and some of the scheduling stuff, but taht's yet to come ,but we're working on it , 6g has a very good goroutines support and much of them on the threads well and implements what we call segmented stacks ,which is how we keep the footprints small but let them grow as they need to . GCC goes a little behind on that because lan has been working on a few other things lately ,But we hope by the end of the year to have all that stuff working in GCC Go and they 'll basically be at the same stage at that point. But even so ,GCC Go can compile all the code and run it now ,The garbage collector , 6g has simple but effective mark-and-sweep collector. And this sounds simple. but work is under the way to do much better job ,with multi-card machines you can actually do concurrent garbage collection with essentially zero latency and very little cost and over head . and IBM has this garbage collector technology taht we think is pretty exciting . we think building  on that stuff ,we can actually make our real goals which are ot avoid a lot of the pitfalls that garbage collector end to have .And we're done work in other language before that indicate this really can be done and now that we have multi-card machines we believe that we can really solve it .GCC Go at the moment has no collector , but ,as I said ,we're working on a common run-time , and I hope by the time this collector is donw is design to run with either compiler ,It's part of the genetal run-time so bot compilers will have real garbage collector s inside of them .There's lot of libraries ,there's tons more to do, but we have a pretty good start ,we've got obviously ,OS and I/O stuff . I showed you  some of that ,It's got a nice math , asimple math package .It got strings ,good support for unicode ,rudimentary but functional regular expression implementation .It's got run-time reflection ,command-line flags and logging, which are very nice to use . It's got full hashes and crypto and all that kind of stuff .It's got a really good testing tool and a library to support it ,standard networking libraries just like you'd expect , including a native PRC implementations. It's kind of pretty .There's really interesting template library based on some work that Andy did that let's you write HTML or ,in fact anything at all using this to generate really simple data driven page generation . It's really quite nice .Andy gets most of the credit for that .There's  a lot more, but you can see there's actually quite a bit in place already .So one of the most interesting programs written in Go is a pair of things that are related-- they share a lot of code -- called Godoc and Gofmt. Godoc is analogous to Javadoc.It serves documents  to request to look up , what this package does or what taht funciton does.And there's a set of links listed there . Golang.org is a top-level guide that's running Godoc. It servers the landing page .And underneath that ,youcan find all the other documents specifications ,editorials and FAQs, and stuff like that ,But if you dig down into the package subdirectory , that's really interesting ,automatically generate the package documentation is especially quite rich .And then under the source directory , the source gets served but ,of cource ,you can get out of this code repository , too ,The difference is that the source is processed by the coding Gofmt. The Gofmt is a pretty printer and all of the coding repository has been formatted by Gofmt .So rather than set a bunch of style rules ,we have a program that says this is what a code looks like , and you just run through Gofmt when you check it in and that's ,just settles all those arguments ,If you want debate ,we got to debate by changing Gofmt ,You cant debate by changing a document ,and I think it's actually , it does an amazingly good job .Actually ,

we have a debugger ,it's not quite ready , but it's pretty close ,
Gccgo users can of course use gdb ,Gdb doesnt understand the symbols tables. 

what about generics

go doesnt have them yet , we dont understand exactly what they do in Go's world .They're quite subtle. The easy examples are easy to write down. It's obvious what the easy examples do ,but the complete ,correct definition is going to be quite complicated. we want to make sure we get it right . In some ways ,Go makes it simpler because there's no type inheritance ,and that eliminates one branch of complexity in generics . But on the other hand ,you can put methods on things that are values of arbitrary size , so ,that's a consequence ,and the other directions are complicates and simplifies at the same time. and we jsut dont think we understand it well enough to do them yet .Also ,in the current world ,although that would be definitely useful and dould solve a lot of problems , the map and slice implementations and the interfaces themselves actually cover a lot of the sort of obvoous examples ofr generics, which is not to say they wouldnt cover a lot of others if they came along ,but the need isn't quite as acute as it is in the language , It doesn have those features ,you can in fact build collections fairly nicely using what's called the MT interface ,which is just interface open close ,That's an interface that implements no methods because everything in hte world satisfies the MT interface . It's kind of a little bit like it but in a completely different meaning the object in Java, And you can build collections that use . There's quite a few checked in ,but they have the disadvantage that they 're not type safe since you have to unbox manually and stuff like that .They're not really what we would propose to do instead . It's just what we're using for now ,why we struggle at this question. So generics ,not yet btu they're very subtle. It's interesting in the codes workbook, josh Black has long discussion about them , 

I think most people think that Java generics works really well including Josh , but he points out they're actually quite a bit harder to get right than you think ,and then maybe it's time to think really hard before you put them in . So ,they may come but they're not there now ,And of course ,there's a million of other thing .Where's my feature ? everybody who programs has a feature they want ,and chances are that some of the things you really think are important are missing ,or thry might be there but not in the way you're used to . Areally good example in inum but there is no iota. And iota's an interesting thing, but it's not an inum ,It's different. So it may not be there ,but there mya be some 

union types is another one we've think about , not done yet 

Effective Go

































































 














 









 








































 








